---
layout: post
title:  "PintOS 제작기 - 1"
date:   2024-08-22 12:00:00 +0900
categories: computer_structures
tags: [C, 운영체제]
---

# PintOS

# 서론

PintOS 중 우리는 카이스트에서 개발한 운영체제를 직접 만들어본다.
이는 주차들로 나뉘어 각각의 프로젝트를 만들게 된다.

## Project 1 - 서론

Project 1에서는 Base kernel의 Source Code를 제작하게 된다.
이는 threads directory에 있다.

또한, I/O device interfacing 과정을 진행하게 되는데, 이는 devices directory에 있다.

## Project 2 - 서론

Project 2 에서는 User Program Loader를 제작하게 된다.
이는 userprog directory에 있다.

lib directory에서 standard C library의 일부를 implement 하게 된다.

## Project 3 - 서론

Project 3 에서는 Virtual Memory를 구현하게 된다.
이는 vm directory에 있다.

## Project 4 - 서론

Project 4 에서는 basic file system을 구현하게 된다.
이는 filesys directory에 있다.

이는 사실 project 2에서 실제로 처음 사용하게 되지만, 내부를 수정하는 것은 Project 4에 와서 진행한다.


# 본론

# Project 1

Project 1에서는 먼저 최소한의 작동하는 쓰레드 시스템을 제공한다.
우리는 이를 확장시키어 동기 문제들에 대해 더 잘 이해하게 될 것이다.
우리는 기본적으로 `threads` directory에서 작업을 진행하고, 또한 `devices` directory에서도 일부의 작업을 진행할 필요성이 있다.
`threads` directory에서 이후 합치는 작업을 진행해야 하며, 이 아래를 진행하기 전에 [Synchronization](https://casys-kaist.github.io/pintos-kaist/appendix/synchronization.html)을 한번 읽어보는 것이 좋겠다.

## Backgrounds

### Understanding Threads

먼저, initial thread system의 코드를 읽고 이해해라.
Pintos는 이미 쓰레드 생성, 쓰레드 Completion(완성, 종료), 쓰레드 사이의 Context Switching을 진행시키는 간단한 스케쥴러와 동기화의 가장 작은 요소들(세마포어, 락, 환경 변수, 최적화 배리어 등...)을 구현시켜 두었다.

코드가 처음에는 좀 어려울 수 있다. 아직 컴파일을 진행하고 베이스 시스템을 돌리지 않았다면, [Introduction](https://casys-kaist.github.io/pintos-kaist/)에서 다시 확인하여 진행하고 이곳으로 돌아오도록 해라.
소스 코드의 모든 부분을 편하게 확인할 수 있다. 필요하다면, `printf()` 문을 이곳저곳에 추가하고 이를 컴파일하여 돌려봄으로써 어떤 일들이 **어떤 순서로** 일어나는지 확인하도록 해라. 또한, 커널을 디버거에서 돌려서, 이곳저곳 흥미로운 지점들에 중단점(breakpoints)을 추가하여 코드 안쪽까지 데이터를 확인해보며 진행하여도 좋다.

쓰레드가 만들어질 때, 우리는 스케쥴될 새로운 context를 만든다. 우리는 이 상황에서 작동하는 함수를 만들어야 하며, 이는 `thread_create()`함수의 인자의 내용으로 전달될 것이다. 
처음 쓰레드가 스케쥴되고 동작할 때, 이 함수로 시작되며 이 내용이 실행될 것이다.
함수가 반환되면, 쓰레드가 종료된다. 각 쓰레드는, 그러므로, 미니 프로그램처럼 동작하며, 이는 `thread_create()`가 `main()` 처럼 실행되며 이에게 넘겨준다.

어떠한 아무런 시간이 주어진다면, 단 하나의 쓰레드만 동작해야 하며, 나머지가 있다면 이들은 비활성화된다.
스케쥴러는 다음에 어떤 쓰레드가 동작해야 하는지를 결정한다(만약 어떠한 쓰레드도 동작할 준비가 주어진 시간에 되지 않는다면, `idle()`로 구현된 특별한 *idle* 쓰레드가 동작한다.).

동기화의 가장 작은 단위들(Synchronization primitives)(위에 설명한 세마포어나 락, 환경변수 등)은 context switch를 한 쓰레드가 다른 쓰레드가 작업할 동안 기다려야 한다면 강제로 발생시킬수 있다.

Context Switch의 동작 과정은 `threads/thread.c` 안에 존재하는 `thread_launch()` 함수에 자세히 담겨 있다(꼭 이해할 필요는 없다.). 이는 현재 동작중인 쓰레드의 상태를 저장하고, 우리가 동작시키고자 하는 쓰레드의 상태를 복원한다.

GDB 디버거를 통해, 천천히 Context Switch를 따라가보면([GDB 문서](https://casys-kaist.github.io/pintos-kaist/project1/introduction.html)) 어떤 일이 일어나는지 알 수 있다.
`schedule()` 함수에 breakpoint를 넣어서 시작해보고, single-step을 넘어가며 확인해봐라.
지속적으로 쓰레드의 주소와 상태를 확인해야 함을 꼭 기억하고, 각 쓰레드별로 어떤 작업들이 call stack에 있는지 확인해라. `do_iret()`에 있는 `iret`이 실행될 때, 다른 쓰레드가 돌아가기 시작한다는걸 곧 알 수 있을 것이다.

**주의사항**: Pintos에서, 각 쓰레드는 4 kB이하의 작은 고정된 실행 스택으로 규정되어 있다. 커널은 스택 오버플로우를 탐지하려 하지만, 이를 완벽하게 해내지는 못한다. 동적 지역변수로 거대한 데이터 구조를 선언하게 되면(예시 : `int buf[1000];`) 전혀 원인파악이 되지않는 커널 패닉(Kernel Panic)등의 기묘한 문제들을 여러분은 일으킬 수 있다. 

이러한 스택 할당의 대안으로는 페이지 할당기와 블록 할당기 등이 존재한다([Memory Allocation 참고](https://casys-kaist.github.io/pintos-kaist/appendix/memory_allocation.html)).

### Source Files

`threads` 와 `include/threads` 의 대한 간략한 요약이다.
이의 대부분의 코드는 굳이 수정할 필요가 없으나, 이를 보면 조금이나마 과제를 수월하게 해낼 수 있을 것이다.

이것들은 [여기](https://casys-kaist.github.io/pintos-kaist/project1/introduction.html)참고합시다.

### Development Suggestions

과거 많은 그룹들은 업무를 분할하였으며, 각 그룹 인원들은 자신의 분담된 업무를 데드라인 직전즈음까지 작업하였다. 이후, 그룹은 이들을 Merge하여 완성된 파일을 만들었는데, 이는 **매우** 좋지 않은 생각이다. 부디 이런방식으로 진행하지 않기를 바란다.
서로간의 코드를 합치다 발생한 오류를 해결하기 위해 마지막 시간들을 부디 허비하지 마라.

대신, git 등을 이용해 소스 코드 컨트롤을 미리미리 진행하여라. 

다양한 버그에 마주칠 수 잇는데, 이럴 때 다시 디버깅 도구들의 appendix를 읽고 해결하여라.
backtraces를 확인하며 kernel panic이나 assertion failure를 해결하기를 바란다.

## Alarm Clock

** `devices/timer.c`에 있는 `timer_sleep()`을 다시 구현해라 **

물론 이미 작동되는 구현이  되어있지만, 이는 **busy wait** 방식을 사용한다.
busy wait은 계속 `thread_yield()` 함수를 통해 현재 시간을 확인하는 루프 속에 계속 존재하여, 충분한 시간이 지날때까지를 기다리는 방식이다.
이를 피할 수 있는 방식을 재구현해라.

---

```c
void timer_sleep (int64_t ticks);
```

`timer_sleep()`은 분명 real-time(실시간)으로 동작하는(예시로 커서를 1초에 한번 깜빡이는 동작) 쓰레드에는 도움이 되는 방식이다.
`timer_sleep()`은 인자가 timer tick 의 형태로 구현되어 있으며, milliesecond나 다른 unit으로 구현되어 있지 않다.



