---
layout: post
title:  "PintOS 제작기 - 2"
date:   2024-09-03 12:00:00 +0900
categories: computer_structures
tags: [C, 운영체제]
use_math: true
---

# PintOS

# 서론

PintOS 중 우리는 카이스트에서 개발한 운영체제를 직접 만들어본다.
이는 주차들로 나뉘어 각각의 프로젝트를 만들게 된다.

## Project 1 - 서론

Project 1에서는 Base kernel의 Source Code를 제작하게 된다.
이는 threads directory에 있다.

또한, I/O device interfacing 과정을 진행하게 되는데, 이는 devices directory에 있다.

## Project 2 - 서론

Project 2 에서는 User Program Loader를 제작하게 된다.
이는 userprog directory에 있다.

lib directory에서 standard C library의 일부를 implement 하게 된다.

## Project 3 - 서론

Project 3 에서는 Virtual Memory를 구현하게 된다.
이는 vm directory에 있다.

## Project 4 - 서론

Project 4 에서는 basic file system을 구현하게 된다.
이는 filesys directory에 있다.

이는 사실 project 2에서 실제로 처음 사용하게 되지만, 내부를 수정하는 것은 Project 4에 와서 진행한다.


# 본론

# Project 3: 가상 메모리

이제 PintOS의 내부 작동 방식에 어느 정도 익숙해졌을 것이다. 운영체제는 적절한 동기화로 여러 스레드를 처리할 수 있고, 동시에 여러 사용자 프로그램을 로드할 수 있다. 그러나, 실행할 수 있는 프로그램의 수와 크기는 머신의 주 메모리 크기에 의해 제한된다. 이번 과제에서는 이러한 제한을 없애고 무한한 메모리가 있는 것처럼 보이도록 구현하게 된다.

이번 과제는 이전 과제 위에 구축된다. Project 2의 테스트 프로그램도 Project 3에서 동작해야 한다. Project 2 제출물에서 발생한 버그를 수정하지 않으면 Project 3에서도 동일한 문제가 발생할 가능성이 높다. 그러므로 Project 3 작업을 시작하기 전에 Project 2에서 발생한 버그를 해결해야 한다.

### 소스 파일

이번 프로젝트는 `vm` 디렉토리에서 작업하게 된다. Makefile은 `-DVM` 설정을 활성화하도록 업데이트되어 있다. 우리는 많은 양의 템플릿 코드를 제공한다. 반드시 주어진 템플릿을 따라야 한다. 템플릿을 기반으로 하지 않은 코드를 제출할 경우, 0점을 받게 된다. 또한 "DO NOT CHANGE"로 표시된 부분은 절대 변경해서는 안 된다. 여기서는 수정하게 될 각 템플릿 파일에 대한 세부 정보를 제공한다.

- `include/vm/vm.h`, `vm/vm.c`  
  가상 메모리에 대한 일반적인 인터페이스를 제공한다. 헤더 파일에서는 여러 `vm_type` (예: `VM_UNINIT`, `VM_ANON`, `VM_FILE`, `VM_PAGE_CACHE`)에 대한 정의와 설명을 볼 수 있다. `VM_PAGE_CACHE`는 Project 4를 위한 것이므로 지금은 무시한다. 보충 페이지 테이블은 이곳에서 구현하게 된다.

- `include/vm/uninit.h`, `vm/uninit.c`  
  초기화되지 않은 페이지(`vm_type = VM_UNINIT`)에 대한 작업을 제공한다. 현재 설계에서는 모든 페이지가 처음에는 초기화되지 않은 페이지로 설정된 후, 익명 페이지 또는 파일 기반 페이지로 변환된다.

- `include/vm/anon.h`, `vm/anon.c`  
  익명 페이지(`vm_type = VM_ANON`)에 대한 작업을 제공한다.

- `include/vm/file.h`, `vm/file.c`  
  파일 기반 페이지(`vm_type = VM_FILE`)에 대한 작업을 제공한다.

- `include/vm/inspect.h`, `vm/inspect.c`  
  채점을 위한 메모리 검사 작업을 포함한다. 이 파일들은 변경하지 않는다.

이 프로젝트에서 작성할 대부분의 코드는 `vm` 디렉토리와 이전 프로젝트에서 소개된 파일에 있을 것이다. 몇몇 파일은 이번에 처음 만나게 될 것이다:

- `include/devices/block.h`, `devices/block.c`  
  블록 장치에 대한 섹터 기반 읽기 및 쓰기 접근을 제공한다. 스왑 파티션에 블록 장치로 접근하기 위해 이 인터페이스를 사용한다.

### 메모리 용어

우리는 메모리와 스토리지와 관련된 몇 가지 용어를 소개한다. 이들 중 일부는 Project 2에서 이미 다루었을 것이다(가상 메모리 레이아웃 참조). 하지만 대부분은 새로운 내용이다.

- **페이지**  
  페이지는 가상 메모리의 연속적인 영역으로, 4,096바이트(페이지 크기) 크기를 가진다. 페이지는 페이지 정렬이 되어야 하며, 가상 주소가 페이지 크기로 나누어떨어지는 위치에서 시작해야 한다. 따라서 64비트 가상 주소의 마지막 12비트는 페이지 오프셋을 나타낸다. 상위 비트는 페이지 테이블의 인덱스를 나타내는 데 사용된다. 64비트 시스템에서는 4단계 페이지 테이블을 사용하며, 가상 주소는 다음과 같이 생긴다:

```lua
63          48 47            39 38            30 29            21 20         12 11         0
+-------------+----------------+----------------+----------------+-------------+------------+
| Sign Extend |    Page-Map    | Page-Directory | Page-directory |  Page-Table |    Page    |
|             | Level-4 Offset |    Pointer     |     Offset     |   Offset    |   Offset   |
+-------------+----------------+----------------+----------------+-------------+------------+
              |                |                |                |             |            |
              +------- 9 ------+------- 9 ------+------- 9 ------+----- 9 -----+---- 12 ----+
                                          Virtual Address
```


각 프로세스는 `KERN_BASE` 가상 주소(0x8004000000) 아래에 있는 독립적인 사용자 페이지 집합을 가진다. 반면 커널 페이지는 전역적이며, 어떤 스레드나 프로세스가 실행 중이든 동일한 위치에 유지된다. 커널은 사용자 페이지와 커널 페이지 모두에 접근할 수 있지만, 사용자 프로세스는 자신의 사용자 페이지에만 접근할 수 있다. 가상 메모리 레이아웃에 대한 자세한 내용은 해당 섹션을 참조한다.

- **프레임**  
프레임은 물리 메모리의 연속적인 영역이다. 페이지와 마찬가지로, 프레임은 페이지 크기여야 하며 페이지 정렬이 되어야 한다. 64비트 물리 주소는 프레임 번호와 오프셋으로 나눌 수 있다:

```lua
                        12 11         0
  +-----------------------+-----------+
  |      프레임 번호      |   오프셋  |
  +-----------------------+-----------+
            물리 주소
```


x86-64 아키텍처는 물리 주소에서 메모리에 직접 접근하는 방법을 제공하지 않는다. Pintos는 커널 가상 메모리를 물리 메모리로 직접 매핑하여 이를 해결한다. 즉, 커널 가상 메모리의 첫 번째 페이지는 물리 메모리의 첫 번째 프레임에, 두 번째 페이지는 두 번째 프레임에 매핑된다. 따라서 커널 가상 메모리를 통해 프레임에 접근할 수 있다. 가상 주소에 대한 자세한 내용은 해당 섹션을 참조한다.

- **페이지 테이블**  
페이지 테이블은 CPU가 가상 주소를 물리 주소로 변환하는 데 사용하는 데이터 구조이다. 페이지 테이블의 형식은 x86-64 아키텍처에 의해 정의된다. Pintos는 `threads/mmu.c`에서 페이지 테이블 관리 코드를 제공한다.

아래 다이어그램은 페이지와 프레임 간의 관계를 보여준다. 왼쪽의 가상 주소는 페이지 번호와 오프셋으로 구성되며, 페이지 테이블은 페이지 번호를 프레임 번호로 변환한 후 오프셋과 결합하여 오른쪽의 물리 주소를 얻는다.

```lua
                        +----------+
       .--------------->| 페이지 테이블 |-----------.
      /                 +----------+              |
      |   12 11 0                               V  12 11 0
  +---------+----+                         +---------+----+
  | 페이지 번호 | 오프셋|                         | 프레임 번호 | 오프셋|
  +---------+----+                         +---------+----+
   가상 주소   |                            물리 주소    ^
                \_______________________________________/

```


- **스왑 슬롯**  
스왑 슬롯은 스왑 파티션의 디스크 공간에서 페이지 크기의 영역이다. 하드웨어의 제한으로 인해 슬롯의 배치가 프레임보다 유연하지만, 슬롯은 페이지 정렬이 되어야 한다. 페이지 교체 정책을 효율적으로 구현하기 위해 스왑 테이블을 사용하여 사용 중인 스왑 슬롯과 여유 슬롯을 추적할 수 있어야 한다.

### 리소스 관리 개요

다음 데이터 구조를 설계하고 구현해야 한다:

- **보충 페이지 테이블**  
페이지 테이블을 보완하여 페이지 폴트 처리를 가능하게 한다.

- **프레임 테이블**  
물리적 프레임의 교체 정책을 효율적으로 구현할 수 있도록 한다.

- **스왑 테이블**  
스왑 슬롯의 사용을 추적한다.

세 가지 데이터 구조를 완전히 구분된 구조로 구현할 필요는 없다. 관련된 리소스를 하나의 통합된 데이터 구조로 합치는 것이 편리할 수 있다.

각 데이터 구조에 대해 각 요소가 어떤 정보를 포함해야 하는지 결정해야 하며, 해당 데이터 구조의 범위가 로컬(프로세스별)인지 전역(시스템 전체에 적용)인지, 그리고 범위 내에서 몇 개의 인스턴스가 필요한지도 결정해야 한다.

설계를 단순화하기 위해 이러한 데이터 구조를 페이지 불가능한 메모리(예: `calloc` 또는 `malloc`으로 할당된 메모리)에 저장할 수 있다. 이렇게 하면 이들 간의 포인터가 유효한 상태로 유지된다.

### 구현 선택 (성능 관점)
구현을 위한 선택 사항으로는 배열, 리스트, 비트맵, 해시 테이블 등이 있다. 배열은 가장 간단한 방법이지만, 인구 밀도가 낮은 배열은 메모리를 낭비할 수 있다. 리스트도 간단하지만, 특정 위치를 찾기 위해 긴 리스트를 순회하는 것은 시간을 낭비할 수 있다. 배열과 리스트는 크기를 조정할 수 있지만, 리스트는 중간에 삽입 및 삭제를 효율적으로 지원한다.

Pintos는 `lib/kernel/bitmap.c`와 `include/lib/kernel/bitmap.h`에 비트맵 데이터 구조를 포함하고 있다. 비트맵은 각 비트가 true 또는 false일 수 있는 비트 배열이다. 비트맵은 일반적으로 동일한 리소스 집합의 사용을 추적하는 데 사용된다. 예를 들어, 리소스 n이 사용 중이라면 비트맵의 n번째 비트가 true로 설정된다. Pintos 비트맵은 고정 크기이지만, 크기 조정을 지원하도록 구현을 확장할 수 있다.

Pintos는 해시 테이블 데이터 구조도 포함하고 있다. Pintos 해시 테이블은 넓은 범위의 테이블 크기에서 효율적인 삽입 및 삭제를 지원한다.

더 복잡한 데이터 구조는 성능이나 기타 이점을 제공할 수 있지만, 불필요하게 구현을 복잡하게 만들 수 있다. 따라서 균형 잡힌 이진 트리와 같은 고급 데이터 구조를 구현하는 것은 권장하지 않는다.

### 보충 페이지 테이블 관리
보충 페이지 테이블은 페이지 테이블의 형식에 의해 부과되는 제한을 보완하기 위해 각 페이지에 대한 추가 데이터를 제공한다. 이러한 데이터 구조는 종종 "페이지 테이블"이라고도 불리지만, 혼동을 줄이기 위해 "보충"이라는 단어를 추가한다.

보충 페이지 테이블은 최소 두 가지 목적을 위해 사용된다. 가장 중요한 것은 페이지 폴트가 발생했을 때 커널이 보충 페이지 테이블에서 해당 가상 페이지를 찾아 그 위치에 어떤 데이터가 있어야 하는지 확인하는 것이다. 두 번째는, 프로세스가 종료될 때 커널이 보충 페이지 테이블을 참조하여 해제해야 할 리소스를 결정하는 것이다.

### 보충 페이지 테이블의 구성
보충 페이지 테이블은 원하는 대로 구성할 수 있다. 기본적인 접근 방식으로는 세그먼트 또는 페이지를 기준으로 한 구성이 있다. 세그먼트는 연속된 페이지 그룹을 의미하며, 실행 파일이나 메모리에 매핑된 파일을 포함하는 메모리 영역이다.

선택적으로, 페이지 테이블 자체를 사용하여 보충 페이지 테이블의 멤버를 추적할 수 있다. 이를 위해 `threads/mmu.c`의 Pintos 페이지 테이블 구현을 수정해야 한다. 이 방법은 고급 학생들에게만 권장된다.

### 페이지 폴트 처리
보충 페이지 테이블의 가장 중요한 사용자는 페이지 폴트 핸들러이다. Project 2에서 페이지 폴트는 항상 커널이나 사용자 프로그램의 버그를 나타냈다. 하지만 Project 3에서는 더 이상 그렇지 않다. 이제 페이지 폴트는 단순히 페이지를 파일이나 스왑 슬롯에서 가져와야 함을 나타낼 수 있다. 이를 처리하기 위해 더 복잡한 페이지 폴트 핸들러를 구현해야 한다. 페이지 폴트 핸들러는 `userprog/exception.c`의 `page_fault()`에서 `vm/vm.c`의 `vm_try_handle_fault()`를 호출하여 처리된다. 페이지 폴트 핸들러는 대략 다음과 같은 작업을 수행해야 한다:

- 보충 페이지 테이블에서 폴트가 발생한 페이지를 찾는다. 메모리 참조가 유효한 경우, 보충 페이지 테이블 항목을 사용하여 페이지에 들어갈 데이터를 찾는다. 해당 데이터는 파일 시스템, 스왑 슬롯에 있을 수 있으며, 단순히 0으로 채워진 페이지일 수도 있다. 공유(Copy-on-Write)를 구현한 경우, 페이지의 데이터가 이미 페이지 프레임에 있을 수 있지만, 페이지 테이블에는 없을 수 있다. 보충 페이지 테이블이 사용자 프로세스가 해당 주소에서 데이터를 기대하지 말아야 한다고 나타내거나, 페이지가 커널 가상 메모리 내에 있거나, 읽기 전용 페이지에 대한 쓰기 시도가 있는 경우, 접근이 유효하지 않다. 모든 유효하지 않은 접근은 프로세스를 종료시키고 그에 따라 모든 리소스를 해제한다.

- 페이지를 저장할 프레임을 확보한다. 공유를 구현한 경우, 필요한 데이터는 이미 프레임에 있을 수 있으며, 이 경우 해당 프레임을 찾아야 한다.

- 파일 시스템 또는 스왑에서 데이터를 프레임으로 가져오거나, 0으로 초기화하는 등의 작업을 수행한다. 공유를 구현한 경우, 필요한 페이지가 이미 프레임에 있을 수 있으며, 이 단계에서 추가 작업이 필요하지 않을 수 있다.

- 폴트가 발생한 가상 주소에 대한 페이지 테이블 항목을 물리 페이지로 가리키도록 설정한다. `threads/mmu.c`의 함수를 사용할 수 있다.

### 프레임 테이블 관리
프레임 테이블은 각 프레임에 대한 항목을 포함한다. 각 항목은 현재 해당 프레임에 있는 페이지에 대한 포인터 및 기타 선택한 데이터를 포함한다. 프레임 테이블은 Pintos가 페이지 교체 정책을 효율적으로 구현할 수 있도록 하며, 프레임이 부족할 때 페이지를 교체하는 페이지를 선택할 수 있도록 한다.

사용자 페이지에 사용되는 프레임은 `palloc_get_page(PAL_USER)`를 호출하여 "사용자 풀"에서 가져와야 한다. `PAL_USER`를 사용하여 "커널 풀"에서 할당하는 것을 피해야 한다. 그렇지 않으면 일부 테스트 케이스가 예상치 못하게 실패할 수 있다. 프레임 테이블 구현의 일부로 `palloc.c`를 수정하는 경우, 두 풀의 구분을 유지해야 한다.

프레임 테이블의 가장 중요한 작업은 사용되지 않은 프레임을 확보하는 것이다. 사용되지 않은 프레임이 있을 때는 이를 확보하는 것이 쉽다. 사용 가능한 프레임이 없으면, 해당 프레임에서 페이지를 교체하여 프레임을 확보해야 한다.

프레임을 교체하지 않고 스왑 슬롯을 할당할 수 없고, 스왑이 가득 찬 경우, 커널을 패닉 상태로 만들어야 한다. 실제 운영 체제는 이러한 상황을 예방하거나 복구하기 위해 다양한 정책을 적용하지만, 이 과제의 범위를 벗어난다.

### 교체 과정의 대략적인 단계는 다음과 같다:
1. 페이지 교체 알고리즘을 사용하여 교체할 프레임을 선택한다. 페이지 테이블의 "accessed" 및 "dirty" 비트가 유용하게 사용될 수 있다.
2. 해당 프레임을 참조하는 모든 페이지 테이블에서 프레임에 대한 참조를 제거한다. 공유를 구현하지 않은 경우, 한 번에 하나의 페이지만 프레임을 참조해야 한다.
3. 필요한 경우, 페이지를 파일 시스템이나 스왑으로 기록한다. 그런 다음 교체된 프레임을 다른 페이지에 사용할 수 있게 한다.

### Accessed 및 Dirty 비트
x86-64 하드웨어는 페이지 교체 알고리즘을 구현하는 데 도움을 줄 수 있는 두 가지 비트를 페이지 테이블 항목(PTE)에 제공한다. 페이지에 읽기 또는 쓰기가 발생하면 CPU는 페이지의 PTE에서 accessed 비트를 1로 설정하고, 쓰기가 발생하면 dirty 비트를 1로 설정한다. CPU는 이 비트를 0으로 재설정하지 않지만, 운영 체제는 이를 재설정할 수 있다.

동일한 프레임을 참조하는 두 개 이상의 페이지, 즉 "alias"에 주의해야 한다. 프레임이 alias된 경우, 해당 프레임에 접근할 때 accessed 및 dirty 비트는 하나의 페이지 테이블 항목(접근에 사용된 페이지에 대한 항목)에서만 업데이트된다. 다른 alias의 accessed 및 dirty 비트는 업데이트되지 않는다.

Pintos에서는 모든 사용자 가상 페이지가 커널 가상 페이지에 alias된다. 이러한 alias를 관리하는 방법을 결정해야 한다. 예를 들어, 코드는 두 주소에 대해 accessed 및 dirty 비트를 확인하고 업데이트할 수 있다. 또는 커널이 사용자 데이터를 사용자 가상 주소를 통해서만 접근하도록 하여 문제를 방지할 수 있다.

다른 alias는 공유를 구현한 경우 또는 코드에 버그가 있을 때만 발생해야 한다.

Accessed 및 Dirty 비트와 관련된 함수에 대한 자세한 내용은 페이지 테이블 Accessed 및 Dirty 비트 섹션을 참조한다.

### 스왑 테이블 관리
스왑 테이블은 사용 중인 스왑 슬롯과 여유 스왑 슬롯을 추적한다. 페이지를 스왑 파티션으로 내보내기 위해 사용되지 않은 스왑 슬롯을 선택할 수 있어야 하며, 페이지가 다시 읽히거나 해당 페이지가 스왑된 프로세스가 종료될 때 슬롯을 해제할 수 있어야 한다.

`vm/build` 디렉토리에서 `pintos-mkdisk swap.dsk --swap-size=n` 명령을 사용하여 스왑 파티션이 있는 n-MB 크기의 디스크 `swap.dsk`를 생성한다. 생성된 `swap.dsk`는 pintos를 실행할 때 자동으로 추가 디스크로 연결된다. 또는, `--swap-size=n` 옵션을 사용하여 임시로 n-MB 크기의 스왑 디스크를 한 번의 실행 동안 사용할 수 있다.

스왑 슬롯은 페이지 교체가 실제로 필요할 때에만 할당되어야 한다(즉, 지연 할당되어야 한다). 프로세스 시작 시 실행 파일에서 데이터 페이지를 읽어와서 바로 스왑에 기록하는 것은 지연 할당이 아니다. 스왑 슬롯은 특정 페이지를 저장하기 위해 미리 예약되어서는 안 된다.

페이지가 프레임으로 다시 읽힐 때, 스왑 슬롯을 해제해야 한다.

### 메모리 매핑된 파일 관리
파일 시스템은 주로 `read` 및 `write` 시스템 콜을 통해 접근된다. 보조 인터페이스로는 `mmap` 시스템 콜을 사용하여 파일을 가상 페이지에 "매핑"하는 방법이 있다. 프로그램은 파일 데이터를 직접 메모리 명령을 통해 접근할 수 있다. 예를 들어, 파일 `foo`가 0x1000 바이트(4KB, 즉 1페이지) 크기라면, `foo`를 가상 주소 0x5000에 매핑하면 0x5000에서 0x5fff까지의 메모리 접근은 `foo`의 해당 바이트에 접근하게 된다.

다음은 `mmap`을 사용하여 파일을 콘솔에 출력하는 프로그램의 예이다. 명령줄에서 지정된 파일을 열고, 가상 주소 0x10000000에 매핑한 다음, 매핑된 데이터를 콘솔(fd 1)에 출력하고, 파일을 언매핑하는 프로그램이다.

```c
#include <stdio.h>
#include <syscall.h>

int main (int argc UNUSED, char *argv[])
{
void *data = (void *) 0x10000000;                 /* 매핑할 주소 */
int fd = open (argv[1]);                          /* 파일 열기 */
void *map = mmap (data, filesize (fd), 0, fd, 0); /* 파일 매핑 */
write (1, data, filesize (fd));                   /* 파일을 콘솔에 출력 */
munmap (map);                                     /* 파일 언매핑 (선택적) */
return 0;
}
```
제출물은 메모리 매핑된 파일이 사용하는 메모리를 추적할 수 있어야 한다. 이는 매핑된 영역에서 발생하는 페이지 폴트를 적절히 처리하고, 매핑된 파일이 프로세스 내의 다른 세그먼트와 겹치지 않도록 보장하는 데 필요하다.

# 메모리 관리

가상 메모리 시스템을 지원하기 위해서는 가상 페이지와 물리 프레임을 효과적으로 관리해야 한다. 이는 어떤(가상 또는 물리) 메모리 영역이 사용되고 있는지, 어떤 목적으로 누구에 의해 사용되고 있는지를 추적해야 한다는 것을 의미한다. 먼저 보충 페이지 테이블을 처리한 다음 물리 프레임을 다루게 될 것이다. 참고로, 이 설명에서는 가상 페이지를 "페이지"라고 부르고, 물리 페이지를 "프레임"이라고 부를 것이다.

### 페이지 구조 및 작업

#### `struct page`

`include/vm/vm.h`에 정의된 페이지는 가상 메모리의 페이지를 나타내는 구조체이다. 이 구조체는 페이지에 대해 알아야 할 모든 필요한 데이터를 저장한다. 현재 템플릿에서 구조체는 다음과 같다:

```c
struct page {
  const struct page_operations *operations;
  void *va;              /* 사용자 공간의 주소 */
  struct frame *frame;   /* 프레임에 대한 역참조 */

  union {
    struct uninit_page uninit;
    struct anon_page anon;
    struct file_page file;
#ifdef EFILESYS
    struct page_cache page_cache;
#endif
  };
};
```

이 구조체는 페이지 작업, 가상 주소, 물리 프레임을 포함하고 있다. 추가로 union 필드도 있다. union은 메모리 영역에 서로 다른 데이터 타입을 저장할 수 있는 특별한 데이터 타입이다. 여러 멤버를 가지고 있지만, 한 번에 하나의 멤버만 값을 가질 수 있다. 이 말은 시스템의 페이지가 `uninit_page`, `anon_page`, `file_page`, 또는 `page_cache`일 수 있다는 뜻이다. 예를 들어, 페이지가 익명 페이지(`Anonymous Page`)라면, `struct page`는 `struct anon_page anon` 필드를 가질 것이며, `anon_page`는 익명 페이지에 대해 필요한 모든 정보를 포함하게 된다.

### 페이지 작업

위에서 설명한 것처럼, 페이지는 `VM_UNINIT`, `VM_ANON`, 또는 `VM_FILE`일 수 있다. 페이지에는 `swap in`, `swap out`, `destroy` 등과 같은 여러 작업이 있다. 각 페이지 타입마다 이러한 작업에 필요한 단계와 작업이 다르다. 즉, `VM_ANON` 페이지와 `VM_FILE` 페이지에는 다른 `destroy` 함수가 호출되어야 한다. 각 함수에서 케이스마다 `switch-case` 구문을 사용할 수도 있지만, 우리는 이를 처리하기 위해 객체 지향 프로그래밍의 "클래스 상속" 개념을 도입한다. 실제로 C 언어에는 "클래스"나 "상속"이 없지만, 함수 포인터를 사용하여 이러한 개념을 구현할 수 있다. 이는 실제 운영체제 코드, 예를 들어 리눅스에서와 유사한 방식으로 구현된다.

함수 포인터는 지금까지 배운 다른 포인터들과 마찬가지로 메모리 내 함수나 실행 가능한 코드를 가리키는 포인터이다. 함수 포인터는 런타임 값에 따라 특정 함수를 실행하는 간단한 방법을 제공하며, 별도의 검사 없이 실행할 수 있다. 우리의 경우, 코드에서 `destroy(page)`를 호출하는 것만으로도 충분하다. 컴파일러는 페이지 타입에 따라 적절한 `destroy` 루틴을 선택하고 해당 함수 포인터를 호출하여 실행한다.

`struct page_operations`는 `include/vm/vm.h`에 정의된 페이지 작업을 위한 구조체이다. 이 구조체는 3개의 함수 포인터를 포함한 함수 테이블로 생각할 수 있다.

```c
struct page_operations {
  bool (*swap_in) (struct page *, void *);
  bool (*swap_out) (struct page *);
  void (*destroy) (struct page *);
  enum vm_type type;
};
```

이제 `page_operations` 구조체를 어디에서 찾을 수 있는지 알아보자. `include/vm/vm.h`에서 `struct page` 구조체를 살펴보면 `operations`라는 필드가 있다. 그리고 `vm/file.c`로 가보면 함수 프로토타입 앞에 `page_operations` 구조체인 `file_ops`가 선언되어 있는 것을 볼 수 있다. 이것은 파일 기반 페이지에 대한 함수 포인터 테이블이다. `.destroy` 필드는 파일 기반 페이지를 제거하는 함수인 `file_backed_destroy`를 가리키며, 이는 같은 파일에서 정의된 함수이다.

함수 포인터 인터페이스로 `file_backed_destroy`가 어떻게 호출되는지 이해해 보자. 예를 들어, `vm_dealloc_page(page)`가 호출되었고, 이 페이지가 파일 기반 페이지(`VM_FILE`)인 경우를 생각해 보자. 함수 내부에서는 `destroy(page)`가 호출된다. `destroy(page)`는 `include/vm/vm.h`에 다음과 같은 매크로로 정의되어 있다:

```c
#define destroy(page) if ((page)->operations->destroy) (page)->operations->destroy (page)
```

이 코드는 `destroy` 함수를 호출하면 실제로는 `(page)->operations->destroy(page)`를 호출하게 된다는 것을 의미한다. 이는 페이지 구조체에서 가져온 `destroy` 함수 포인터를 호출하는 방식이다. 해당 페이지가 `VM_FILE` 페이지이므로, 이 페이지의 `.destroy` 필드는 `file_backed_destroy`를 가리킨다. 결과적으로, 파일 기반 페이지에 대한 `destroy` 루틴이 실행된다.

### 보충 페이지 테이블 구현

현재 Pintos는 가상 메모리와 물리 메모리 매핑을 관리하기 위한 페이지 테이블(pml4)을 가지고 있다. 하지만 이것만으로는 충분하지 않다. 앞에서 논의한 것처럼, 페이지 폴트와 리소스 관리를 처리하기 위해 각 페이지에 대한 추가 정보를 보관할 수 있는 보충 페이지 테이블이 필요하다. 따라서 Project 3의 첫 번째 작업으로 보충 페이지 테이블의 기본 기능을 구현할 것을 제안한다.

`vm/vm.c`에서 보충 페이지 테이블 관리 기능을 구현하라.

먼저 Pintos에서 보충 페이지 테이블을 어떻게 설계할 것인지 결정해야 한다. 보충 페이지 테이블을 설계한 후, 해당 설계에 맞춰 다음 세 가지 기능을 구현하라.

```c
void supplemental_page_table_init (struct supplemental_page_table *spt);
```

보충 페이지 테이블을 초기화한다. 보충 페이지 테이블에 사용할 데이터 구조는 선택할 수 있으며, 이 함수는 새로운 프로세스가 시작될 때(`userprog/process.c`의 `initd`에서) 및 프로세스가 포크될 때(`userprog/process__do_fork`에서) 호출된다.

```c
struct page *spt_find_page (struct supplemental_page_table *spt, void *va);
```

주어진 보충 페이지 테이블에서 가상 주소 `va`에 해당하는 `struct page`를 찾는다. 실패할 경우 `NULL`을 반환한다.

```c
bool spt_insert_page (struct supplemental_page_table *spt, struct page *page);
```

주어진 보충 페이지 테이블에 `struct page`를 삽입한다. 이 함수는 가상 주소가 이미 보충 페이지 테이블에 존재하지 않는지 확인해야 한다.

주어진 보충 페이지 테이블에 `struct page`를 삽입한다. 이 함수는 가상 주소가 이미 보충 페이지 테이블에 존재하지 않는지 확인해야 한다.

### 프레임 관리

이제부터 모든 페이지는 단순히 메모리의 메타데이터를 가지고 있을 뿐만 아니라, 물리 메모리를 관리할 수 있는 구조로 변해야 한다. `include/vm/vm.h`에는 물리 메모리를 나타내는 `struct frame`이 존재한다. 현재 템플릿에서의 구조체는 다음과 같다:

```c
/* "frame"의 표현 */
struct frame {
  void *kva;
  struct page *page;
};
```

이 구조체는 두 가지 필드만 가지고 있는데, `kva`는 커널 가상 주소를 나타내고, `page`는 페이지 구조체를 가리킨다. 프레임 관리 인터페이스를 구현하면서 더 많은 멤버를 추가할 수 있다.

다음 함수들을 `vm/vm.c`에서 구현하라:

```c
static struct frame *vm_get_frame (void);
```

사용자 풀에서 `palloc_get_page`를 호출하여 새로운 물리 페이지를 얻는다. 사용자 풀에서 페이지를 성공적으로 얻었을 때, 프레임도 할당하고, 멤버들을 초기화한 후 반환한다. `vm_get_frame`을 구현한 후에는 모든 사용자 공간 페이지(PALLOC_USER)를 프레임 관리 인터페이스를 구현하면서 더 많은 멤버를 추가할 수 있다.

```c
static struct frame *vm_get_frame (void);
```

사용자 풀에서 `palloc_get_page`를 호출하여 새로운 물리 페이지를 얻는다. 사용자 풀에서 페이지를 성공적으로 얻었을 때, 프레임도 할당하고, 멤버들을 초기화한 후 반환한다. `vm_get_frame`을 구현한 후에는 모든 사용자 공간 페이지(PALLOC_USER)를 이 함수를 통해 할당해야 한다. 페이지 할당 실패 시 스왑 아웃을 처리할 필요는 없으며, 해당 경우에는 `PANIC("todo")`로 표시해두면 된다.

```c
bool vm_do_claim_page (struct page *page);
```

페이지를 클레임하여(즉, 물리 프레임을 할당하여) 해당 페이지를 처리한다. 먼저 `vm_get_frame`을 호출하여 프레임을 가져온다(이는 템플릿에서 이미 제공된 기능이다). 이후 MMU(Memory Management Unit)를 설정해야 한다. 즉, 가상 주소에서 물리 주소로의 매핑을 페이지 테이블에 추가한다. 이 함수의 반환 값은 작업의 성공 여부를 나타내야 한다.

```c
bool vm_claim_page (void *va);
```

가상 주소 `va`에 대한 페이지를 클레임한다. 먼저 페이지를 가져온 후, `vm_do_claim_page`를 해당 페이지와 함께 호출한다.

# 익명 페이지 (Anonymous Page)

이 부분에서는 디스크 기반 이미지가 아닌, 익명 페이지(anonymous page)를 구현하게 된다.

익명 매핑은 백업 파일이나 장치가 없다. 즉, 익명 페이지는 파일을 소스로 가지지 않기 때문에 '익명'이라고 불린다. 익명 페이지는 스택과 힙 같은 실행 파일에서 사용된다.

익명 페이지를 설명하기 위한 구조체는 `include/vm/anon.h`에 있는 `anon_page`이다. 현재는 비어 있지만, 익명 페이지를 구현하면서 필요한 정보나 상태를 저장할 멤버를 추가할 수 있다. 또한 `include/vm/page.h`에 있는 `struct page`를 참조하여 페이지의 일반적인 정보를 확인할 수 있다. 익명 페이지의 경우, `struct anon_page anon`이 페이지 구조체에 포함된다.

## 지연 로딩(Lazy Loading)을 통한 페이지 초기화

지연 로딩은 메모리 로딩을 실제로 필요할 때까지 미루는 디자인이다. 페이지가 할당되어 대응하는 페이지 구조체가 존재하지만, 물리적 프레임이 할당되지 않았고, 실제 페이지 내용도 아직 로드되지 않는다. 내용은 페이지 폴트가 발생할 때 로드된다.

우리는 세 가지 페이지 타입을 다루기 때문에 초기화 루틴은 각 페이지마다 다르다. 아래에서 다시 설명되겠지만, 여기서는 페이지 초기화 흐름의 높은 수준의 개요를 제공한다. 먼저 `vm_alloc_page_with_initializer`는 커널이 새 페이지 요청을 받으면 호출된다. 초기화자는 페이지 타입에 따라 적절한 초기화를 설정하고 페이지 구조체를 할당한 후 사용자 프로그램에 제어를 돌려준다. 사용자 프로그램이 실행되는 동안, 어느 시점에 프로그램이 페이지에 접근하려 시도하지만 해당 페이지에는 아직 내용이 없어 페이지 폴트가 발생하게 된다. 폴트 처리 절차에서 `uninit_initialize`가 호출되며, 이때 설정된 초기화자가 호출된다. 익명 페이지의 경우 `anon_initializer`, 파일 기반 페이지의 경우 `file_backed_initializer`가 호출된다.

페이지는 `초기화->(페이지 폴트->지연 로드->스왑 인->스왑 아웃->...) ->소멸`의 생명 주기를 가질 수 있다. 각 생명 주기 전환에서 필요한 절차는 페이지 타입(또는 `VM_TYPE`)에 따라 다르다. 이번 프로젝트에서는 각 페이지 타입에 대해 이러한 전환 과정을 구현하게 된다.

## 실행 파일에 대한 지연 로딩

지연 로딩에서는 프로세스가 실행을 시작할 때, 즉시 필요한 메모리 부분만 메인 메모리에 로드된다. 이는 모든 바이너리 이미지를 한 번에 메모리에 로드하는 "빠른 로딩"에 비해 오버헤드를 줄일 수 있다.

지연 로딩을 지원하기 위해, `include/vm/vm.h`에 `VM_UNINIT`라는 페이지 타입이 도입되었다. 모든 페이지는 처음에 `VM_UNINIT` 페이지로 생성된다. 우리는 또한 초기화되지 않은 페이지를 위한 구조체인 `struct uninit_page`를 `include/vm/uninit.h`에 제공한다. 초기화되지 않은 페이지를 생성하고 초기화하며 파괴하는 함수들은 `include/vm/uninit.c`에서 찾을 수 있다. 이러한 함수들을 나중에 완성해야 한다.

페이지 폴트가 발생하면, 페이지 폴트 핸들러(`userprog/exception.c`의 `page_fault`)는 `vm/vm.c`의 `vm_try_handle_fault`로 제어를 넘긴다. 여기서는 해당 폴트가 유효한지 확인한다. 유효한 폴트란 잘못된 접근이 아닌 경우를 의미한다. 잘못된 폴트가 아니라면 페이지에 어떤 내용을 로드한 후 사용자 프로그램에 제어를 돌려준다.

잘못된 페이지 폴트는 세 가지 경우가 있다: 지연 로딩된 페이지, 스왑 아웃된 페이지, 쓰기 보호된 페이지(복사-온-라이트 참조). 지금은 첫 번째 경우인 지연 로딩된 페이지만 고려하면 된다. 지연 로딩을 위한 페이지 폴트라면, 커널은 `vm_alloc_page_with_initializer`에서 설정된 초기화자 중 하나를 호출하여 세그먼트를 지연 로드하게 된다. `userprog/process.c`에서 `lazy_load_segment`를 구현해야 한다.

**`vm_alloc_page_with_initializer()`를 구현하라.** 전달된 `vm_type`에 따라 적절한 초기화자를 선택하고, `uninit_new`와 함께 호출해야 한다.

```c
bool vm_alloc_page_with_initializer (enum vm_type type, void *va,
        bool writable, vm_initializer *init, void *aux);
```

- 주어진 타입으로 초기화되지 않은 페이지를 생성하라. `uninit` 페이지의 `swap_in` 핸들러는 페이지 타입에 따라 자동으로 페이지를 초기화하며, 주어진 `INIT`과 `AUX` 값을 사용하여 초기화 작업을 수행한다. 페이지 구조체를 생성한 후, 해당 페이지를 프로세스의 보충 페이지 테이블에 삽입해야 한다. 이때, `vm.h`에 정의된 `VM_TYPE` 매크로를 사용하는 것이 유용할 수 있다.

페이지 폴트 핸들러는 호출 체인을 따라가며, 최종적으로 `swap_in`을 호출할 때 `uninit_initialize` 함수에 도달한다. 이를 위한 완전한 구현은 제공되었지만, 디자인에 따라 `uninit_initialize` 함수를 수정해야 할 수 있다.

```c
static bool uninit_initialize (struct page *page, void *kva);
```


```c
void vm_anon_init (void);
```
